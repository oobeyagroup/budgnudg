
# üí∞ Budget Feature Implementation Plan

## üöÄ IMPLEMENTATION DECISIONS (FINALIZED)

### Architecture Decisions:
1. **User Scope**: Single-user application - skip user foreign keys
2. **Needs Level**: Reuse existing needs_level values from Transaction model consistently across historical and budget data
3. **Category Hierarchy**: Support budgets at both category and subcategory levels following existing precedence rules
4. **Recurring Integration**: Budget recurring items must be logically consistent with transaction recurring patterns - users should be able to connect recurring transactions to recurring budget items
5. **Bootstrap Version**: Use Bootstrap 5 (most recent) - update any outdated code

### App Structure:
- **New App**: `budgets/` - separate from transactions for modularity
- **Models**: Budget, BudgetPeriod with integration to existing Category, Payoree, needs_level
- **Services**: BaselineCalculator, BudgetWizard leveraging existing AI categorization
- **UI**: Bootstrap 5 wizard with inline editing, following existing CBV patterns

---

## Original Implementation Discussion

## ChatGPT said:
Great ‚Äî you're establishing a clear conceptual distinction between:
- Transactions (past, factual)
- Budgets (user-defined intentions/targets)
- Forecasts (app-generated future projections)

Let‚Äôs start by summarizing your preamble and building toward a proposed model structure for Budget and Forecast, followed by a list of clarifying questions.

üßæ Preamble Summary
1. Transactions
Represent historical spending events with attributes like:
    - `date, amount`
    - `category, subcategory, payoree`
    - Additional enrichments (e.g. `needs_level, tags, notes`)

2. Budget
Represents user-defined spending intentions over time.
    - Can be scoped by category, subcategory, and/or payoree
    - May be time-bound (monthly/quarterly/annual budgets)
    - Multiple budget entries may coexist per user (e.g. for different time windows)
    - App helps *compare budgets vs actuals* from Transactions

3. Forecast
Represents *predicted spending*, not user-defined.
    - Uses historical data (Transaction history)
    - Can be scoped the same way as Budget (category, etc.)
    - Automatically updated as new data comes in
    - Could support multiple forecast methods (e.g. rolling average, seasonal trend)

### ‚úÖ Suggested Model Updates
1. Budget Model
``` python
class Budget(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, null=True, blank=True, on_delete=models.CASCADE)
    subcategory = models.ForeignKey(Subcategory, null=True, blank=True, on_delete=models.CASCADE)
    payoree = models.ForeignKey(Payoree, null=True, blank=True, on_delete=models.CASCADE)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    period_start = models.DateField()
    period_end = models.DateField()
    note = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
```
üîé This model supports:
    - Budgets scoped by any of the key analysis axes (category, subcategory, payoree)
    - Time-based budgets (month, quarter, custom)
    - Comparison with transaction totals in the same scope and period
2. Forecast Model
``` python
class Forecast(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    category = models.ForeignKey(Category, null=True, blank=True, on_delete=models.CASCADE)
    subcategory = models.ForeignKey(Subcategory, null=True, blank=True, on_delete=models.CASCADE)
    payoree = models.ForeignKey(Payoree, null=True, blank=True, on_delete=models.CASCADE)
    forecast_period_start = models.DateField()
    forecast_period_end = models.DateField()
    predicted_amount = models.DecimalField(max_digits=10, decimal_places=2)
    method = models.CharField(max_length=50)  # e.g., 'linear_regression', 'avg_3mo', 'last_year'
    confidence = models.FloatField(null=True, blank=True)  # optional
    created_at = models.DateTimeField(auto_now_add=True)
```
üîé Supports:
    - Multiple forecast strategies
    - Rolling forecasts
    - Confidence scoring (optional)
    - Could be regenerated by a scheduled job or trigger

‚ùì Clarifying Questions
1. Granularity
    - Will budgeting always be done per month? Or should it support flexible date ranges (e.g. biweekly, custom periods)?
    - Should the budget be recurring (e.g., $500/month for groceries every month), or are they one-offs?
2. User Preferences
    - Will users define budget amounts directly, or do you want to support AI/ML suggestions for target amounts?
    - Should we track actuals vs budget with a status field (e.g., under, on target, over)?
3. Forecasting Frequency
     -Should forecast be updated continuously (e.g., nightly job), manually by user, or on-demand?
4. Categorization Ambiguity
    - How should we handle overlapping scopes? For example:
    - A budget for category = Food and another for payoree = Whole Foods
    - Which one "counts" for a given transaction?
5. Multiple Users / Household Support?
    - Do you plan to support household/shared budgeting (multiple users on one plan), or is this single-user for now?
6. UI Concepts
    - Do you want to support budget groups or envelopes (e.g., "Essentials", "Discretionary", "Savings Goals")?

Would you like me to generate Django migrations and admin/register files for this model scaffold?

Also, if you already have a Category, Subcategory, and Payoree model defined, I‚Äôll assume they are being reused here. Let me know if any of them are not implemented yet.

## You said:
Answers:
1. Granularity:  Monthly is the finest granularity
2. User preference: user will define budget directly.  there will be an AI/ML suggested amount to support a 1-click populate.
3. Frequency: forecast will be on-demand only
4. Precedent should be category over payoree
5. single user for now.
6. Accomplish this through the existing needs_level field

Category, Subcategory, and Payoree model are already defined and will be reused.

## ChatGPT said:
Perfect. Based on your answers, here's an updated and final version of the model design for both Budget and Forecast, aligned with your intended use and existing app structure.

### ‚úÖ Final Model Design
1. Budget Model

``` python
class Budget(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    category = models.ForeignKey("Category", null=True, blank=True, on_delete=models.CASCADE)
    subcategory = models.ForeignKey("Subcategory", null=True, blank=True, on_delete=models.CASCADE)
    payoree = models.ForeignKey("Payoree", null=True, blank=True, on_delete=models.CASCADE)
    
    needs_level = models.CharField(
        max_length=20,
        choices=NEEDS_LEVEL_CHOICES,  # Reuse from Transaction model
        null=True,
        blank=True,
    )

    year = models.PositiveIntegerField()
    month = models.PositiveSmallIntegerField()

    amount = models.DecimalField(max_digits=10, decimal_places=2)
    user_note = models.TextField(blank=True)

    is_ai_suggested = models.BooleanField(default=False)  # True if auto-filled by system
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("user", "year", "month", "category", "subcategory", "payoree", "needs_level")
        ordering = ["-year", "-month"]

    def __str__(self):
        return f"{self.category or ''} / {self.subcategory or ''} / {self.payoree or ''} - {self.month}/{self.year}"
```

2. Forecast Model

``` python
class Forecast(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    category = models.ForeignKey("Category", null=True, blank=True, on_delete=models.CASCADE)
    subcategory = models.ForeignKey("Subcategory", null=True, blank=True, on_delete=models.CASCADE)
    payoree = models.ForeignKey("Payoree", null=True, blank=True, on_delete=models.CASCADE)

    needs_level = models.CharField(
        max_length=20,
        choices=NEEDS_LEVEL_CHOICES,
        null=True,
        blank=True,
    )

    year = models.PositiveIntegerField()
    month = models.PositiveSmallIntegerField()

    predicted_amount = models.DecimalField(max_digits=10, decimal_places=2)
    method = models.CharField(max_length=50)  # e.g., "avg_last_3mo", "last_year_same_month"
    confidence = models.FloatField(null=True, blank=True)  # Optional ML confidence rating

    generated_at = models.DateTimeField(auto_now_add=True)

    class Meta:
        unique_together = ("user", "year", "month", "category", "subcategory", "payoree", "needs_level")
        ordering = ["-year", "-month"]

    def __str__(self):
        return f"Forecast {self.month}/{self.year} - {self.category or ''}/{self.subcategory or ''}"
```

### üîß Additional Design Notes
- Granularity is at the month level (year, month) ‚Äî no need for full date fields.
- Budget entry can be scoped at any level: just category, or more precise (e.g., subcategory + payoree). This will help keep the UX flexible.
- Conflict resolution precedence: your logic (in reporting or budget-vs-actual calculations) should:
    1. Prefer Category-level budgets first,
    2. Then Subcategory,
    3. Then Payoree ‚Äî in line with your answer to Q4.
- Forecast method field allows plug-and-play of different algorithms without needing schema changes.
Would you like:
- ‚úÖ A Django migration for these?
- ‚úÖ Admin setup for in-app management?
- ‚úÖ Query helpers or comparison logic (e.g., get_actual_vs_budget())?
Let me know how you want to proceed ‚Äî or if you'd like to mock up the UI flows for budgeting or forecasting next.

## You said:
Based on these models, Envision a feature that would help the user establish a budget based on historical transaction data. It should use bootstrap for user friendliness as measured by fewest keystrokes and clicks. IT should start with a realistic budget that extends past spending, then guides the user through target spending adjustments to achieve new targets.

## ChatGPT said:

Thought for 10s
Love it. Here‚Äôs a QuickStart Budget Wizard that turns your history into a realistic, editable budget with minimal typing/clicking. It‚Äôs Bootstrap-first, keyboardable, and respects your model choices (monthly granularity, category‚âªsubcategory‚âªpayoree precedence, optional needs_level, on-demand forecasts, and 1-click AI/ML suggestions).

### QuickStart Budget Wizard ‚Äî UX flow (Bootstrap)
*Entry point:* /budget/wizard
*Goal:* Create (or refresh) Budget rows for the next 3‚Äì12 months from historical Transactions, then guide user to nudge targets.
#### Step 0 - Scan & Prefill (no input)
    - Auto-detect historical window (default: last 12 full months).
    - Compute Baseline per scope (Category ‚Üí Subcategory ‚Üí Payoree) using precedence.
    - Show a single card ‚ÄúBaseline ready‚Äù with:
        - Period summarised (e.g., ‚ÄúOct 2024‚ÄìSep 2025‚Äù)
        - Detected monthly spend (median of trailing 3/6/12, seasonality-aware)
        - Buttons: ‚ÄúUse 12-mo median (recommended)‚Äù, dropdown for ‚ÄúLast 6-mo avg‚Äù, ‚ÄúSame month last year‚Äù, ‚ÄúLow outlier-trimmed avg‚Äù.
    - *Zero clicks if you accept default:* press *Enter* to continue.
#### Step 1 ‚Äî Draft Budget (one screen, inline edit)
A responsive, sticky-header table (Bootstrap table table-sm table-hover align-middle) with in-cell editing:
Columns:
-Category (badge), Subcategory (muted), Payoree (muted)
-Needs level (pill badges; filterable)
-Baseline (computed), Budget (editable)
-Œî (Budget ‚àí Baseline), %Œî (badge w/ color), Monthly impact (sum)
- Include (toggle)
*UX accelerators:*
- Editable Budget is focused by keyboard as you arrow down.
- Keyboard shortcuts: ‚Üë/‚Üì move rows; [/] nudge ‚àí/+ 5%; r reset to baseline; x toggle include.
- Top controls: ‚ÄúSelect All‚Äù, ‚ÄúOnly Essentials‚Äù, ‚ÄúOnly Discretionary‚Äù, search box.
- Pills (one-click filters): All, Housing, Food, Transport, ‚Ä¶ plus your needs_level set.
*Right rail (sticky):*
- Running totals: Sum of included Budgets, vs historical, and vs income (optional).
- Constraint slider: ‚ÄúTarget total monthly spend: $____‚Äù. Dragging it proportionally scales selected lines (with locks).
*One-click populate:*
- ‚ÄúAI Suggest‚Äù (uses your analytics service below) ‚Üí instantly fills Budget cells; user tweaks only exceptions.
#### Step 2 ‚Äî Guardrails & Goals
- Optional caps/floors by needs_level (e.g., Essentials ‚â• baseline, Discretionary ‚àí10% cap).
- ‚ÄúReallocate savings‚Äù toggle: reductions from one line auto-redistribute to debt paydown or savings envelope rows (shown as pseudo-categories for clarity).
#### Step 3 ‚Äî Apply & Rollout
- Choose months to apply: next 3 / 6 / 12 months (radio).
- ‚ÄúOverwrite existing budgets for these months?‚Äù (default: yes, for same scope keys).
- Commit ‚Üí writes Budget rows for each (user, year, month, scope, needs_level).
#### Step 4 ‚Äî Review (Budget vs Actual dashboard)
- Card grid with sparklines: top categories, over/under badges.
- Buttons: ‚ÄúExport CSV‚Äù, ‚ÄúOpen Budget Calendar‚Äù, ‚ÄúCreate On-Demand Forecast‚Äù.

### Data & services (Django-centric)
#### Service: baseline & suggestion engine
Create transactions/services/budgeting.py:
``` python
from datetime import date
from decimal import Decimal
from collections import defaultdict
from django.db.models import Sum
from ..models import Transaction

def historical_baseline(user, start, end, method="median12", needs_level=None):
    """
    Returns dict keyed by (category_id, subcat_id, payoree_id, needs_level)
    with {'monthly_baseline': Decimal, 'support': {...stats...}}
    Respects precedence: roll up to category when conflicts arise.
    """
    qs = Transaction.objects.filter(user=user, date__gte=start, date__lt=end)
    if needs_level:
        qs = qs.filter(needs_level=needs_level)

    # Aggregate by month + scope
    rows = qs.values(
        "category_id", "subcategory_id", "payoree_id", "needs_level",
        "date__year", "date__month"
    ).annotate(total=Sum("amount"))

    # Build per-scope monthly series
    series = defaultdict(lambda: defaultdict(Decimal))
    for r in rows:
        key = (r["category_id"], r["subcategory_id"], r["payoree_id"], r["needs_level"])
        ym = (r["date__year"], r["date__month"])
        series[key][ym] += Decimal(r["total"])

    # Compute baseline per key with chosen method
    result = {}
    for key, months in series.items():
        monthly_vals = list(months.values())
        if not monthly_vals:
            continue
        baseline = _method_picker(monthly_vals, method)  # median/trimmed mean/etc.
        result[key] = {"monthly_baseline": baseline, "support": {"n_months": len(monthly_vals)}}
    return _apply_precedence_collapse(result)

def _method_picker(vals, method):
    vals = sorted(vals)
    if method == "median12":
        mid = len(vals)//2
        return (vals[mid] if len(vals)%2 else (vals[mid-1]+vals[mid])/2)
    if method == "avg6":
        return sum(vals[-6:]) / max(1, min(6, len(vals)))
    if method == "same_month_last_year":
        # caller should pass only that month; otherwise approximate with median
        return vals[len(vals)//2]
    # trimmed mean 20% as a robust default
    k = max(1, int(0.2*len(vals)))
    trimmed = vals[k:len(vals)-k] if len(vals) > 2*k else vals
    return sum(trimmed)/len(trimmed)

def _apply_precedence_collapse(result):
    """
    Enforce Category ‚âª Subcategory ‚âª Payoree.
    If a category has a baseline, drop conflicting finer keys unless
    they‚Äôre explicitly marked to be kept (future option).
    """
    by_cat = defaultdict(list)
    for key in result:
        cat, sub, pay, nl = key
        by_cat[(cat, nl)].append(key)

    final = {}
    for (cat, nl), keys in by_cat.items():
        # If there‚Äôs a pure category row (sub=pay=None), keep it and discard children
        cat_only = [k for k in keys if k[1] is None and k[2] is None]
        if cat_only:
            for k in cat_only:
                final[k] = result[k]
        else:
            # else allow subcat rows; if subcat-only exists, suppress payoree rows under them
            subs = [k for k in keys if k[1] is not None and k[2] is None]
            if subs:
                for k in subs:
                    final[k] = result[k]
                # keep only payoree rows belonging to categories without a subcat rollup
                # (optional stricter pruning depending on your preference)
            else:
                # only payoree rows remain
                for k in keys:
                    final[k] = result[k]
    return final
```
#### Service: 1-click AI suggest
- Wrap historical_baseline() plus heuristics:
    - Essentials (needs_level critical/core): max(baseline, last-3-mo median)
    - Discretionary: min(baseline, ‚àí10% nudge), floor at a small anchor
    - Seasonal categories (detect via month-over-month variance): apply seasonal factors
Return per-row suggested_budget and confidence.

### Views & endpoints
- GET /budget/wizard ‚Üí renders Step 0, lazy loads baseline.
- GET /api/budget/baseline?period=12m&method=median12 ‚Üí returns JSON of rows with monthly_baseline.
- POST /api/budget/suggest (payload: selected rows, guardrails) ‚Üí returns suggested Budget values.
- POST /api/budget/commit (payload: rows + months) ‚Üí creates/updates Budget records.

Use bulk_create(..., update_conflicts=True, unique_fields=[...], update_fields=[...]) on Django 5 to upsert by your unique_together.

### Bootstrap UI details (minimal clicks)
- Top bar: period dropdown (6/12/24m), method dropdown, ‚ÄúAI Suggest‚Äù button, search.
- Table: contenteditable inputs or small <input type="number" class="form-control form-control-sm">.
- Badges: %Œî uses contextual classes (text-success, text-danger).
- Toasts: changes saved, conflicts, overwrite warnings.
- Sticky footer: Totals + ‚ÄúApply to next: 3 / 6 / 12 months‚Äù radio + Commit button.

### Budget write logic (upsert)
``` python 
from django.db import transaction as dbtx
from budgets.models import Budget

def commit_budgets(user, rows, months_to_apply, year_month_start):
    """
    rows: list of dicts with keys:
      category_id, subcategory_id, payoree_id, needs_level, amount
    months_to_apply: int
    year_month_start: (year, month)
    """
    budgets = []
    y, m = year_month_start
    for i in range(months_to_apply):
        yy = y + (m + i - 1)//12
        mm = (m + i - 1)%12 + 1
        for r in rows:
            budgets.append(Budget(
                user=user, year=yy, month=mm,
                category_id=r.get("category_id"),
                subcategory_id=r.get("subcategory_id"),
                payoree_id=r.get("payoree_id"),
                needs_level=r.get("needs_level"),
                amount=r["amount"],
                is_ai_suggested=r.get("is_ai_suggested", False),
            ))
    with dbtx.atomic():
        Budget.objects.bulk_create(
            budgets,
            update_conflicts=True,
            unique_fields=["user","year","month","category","subcategory","payoree","needs_level"],
            update_fields=["amount","is_ai_suggested","updated_at"]
        )
```
### Comparison helpers (Budget vs Actuals)
Provide a service get_budget_vs_actual(user, year, month) that:
- Pulls relevant Budget rows and actual Transaction sums for that same month and scope.
- Applies precedence when matching actuals to budgets.
- Returns a structure your table renders directly.
### Forecast (on-demand)
Add a ‚ÄúForecast month‚Äù button on the Review screen that:
- Calls a simple model (e.g., avg of last N months + seasonality).
- Populates Forecast rows for selected months (no user typing).
- Shows a badge with confidence and a sparkline.
### Why this meets ‚Äúfewest keystrokes/clicks‚Äù
- Default baseline chosen and Enter advances.
- One-click AI Suggest fills everything.
- Inline edits with arrow-key navigation and tiny shortcut keys adjust budgets in seconds.
- Scaling slider applies total-spend targets across selected rows automatically.
- Single Commit upserts 3/6/12 months.
